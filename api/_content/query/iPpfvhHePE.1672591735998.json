[{"_path":"/plugins/helo.checks","_dir":"plugins","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"helo.checks - HELO Checks plugin for Haraka","description":"Haraka helo.checks plugin - Rejects messages with invalid HELO/EHLO","excerpt":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"helochecks-plugin"},"children":[{"type":"text","value":"helo.checks plugin"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This plugin performs a number of checks on the HELO string."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HELO strings are very often forged or dubious in spam and so this can be a\nhighly effective and false-positive free anti-spam measure."}]},{"type":"element","tag":"h2","props":{"id":"usage"},"children":[{"type":"text","value":"Usage"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"helo.checks results can be accessed by subsequent plugins:"}]},{"type":"element","tag":"code","props":{"code":"var h = connection.results.get('helo.checks');\nif (h.pass && h.pass.length > 5) {\n    // nice job, you passed 6+ tests\n}\nif (h.fail && h.fail.length > 3) {\n    // yikes, you failed 4+ tests!\n}\nif (connection.results.has('helo.checks','pass', /^forward_dns/) {\n    // the HELO hostname is valid\n}\n","language":"js"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"var h = connection.results.get('helo.checks');\nif (h.pass && h.pass.length > 5) {\n    // nice job, you passed 6+ tests\n}\nif (h.fail && h.fail.length > 3) {\n    // yikes, you failed 4+ tests!\n}\nif (connection.results.has('helo.checks','pass', /^forward_dns/) {\n    // the HELO hostname is valid\n}\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"configuration"},"children":[{"type":"text","value":"Configuration"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"helo.checks.regexps"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"List of regular expressions to match against the HELO string. The regular\nexpressions are automatically wrapped in "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"^"}]},{"type":"text","value":" and "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"$"}]},{"type":"text","value":" so they always match\nthe entire string."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"helo.checks.ini"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"INI file which controls enabling of certain checks:"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"dns_timeout=30"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"How many seconds to wait for DNS queries to timeout."}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"check"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"check"}]}]},{"type":"element","tag":"code","props":{"code":"* valid\\_hostname=true\n\n  Checks that the HELO has at least one '.' in it and the organizational\n  name is possible (ie, a host within a Public Suffix).\n\n* bare\\_ip=true\n\n  Checks for HELO <IP> where the IP is not surrounded by square brackets.\n  This is an RFC violation so should always be enabled.\n\n* dynamic=true\n\n  Checks to see if all or part the connecting IP address appears within\n  the HELO argument to indicate that the client has a dynamic IP address.\n\n* literal\\_mismatch=1|2|3\n\n  Checks to see if the IP literal used matches the connecting IP address.\n  If set to 1, the full IP must match.  If set to 2, the /24 must match.\n  If set to 3, the /24 may match, or the IP can be private (RFC 1918).\n\n* match\\_re=true\n\n  See above. This is merely an on/off toggle.\n\n* big\\_company=true\n\n  See below. This is merely an on/off toggle.\n\n* forward\\_dns=true\n\n  Perform a DNS lookup of the HELO hostname and validate that the IP of\n  the remote is included in the IP(s) of the HELO hostname.\n\n  This test requires that the valid\\_hostname check is also enabled.\n\n* rdns\\_match=true\n\n  Sees if the HELO hostname (or at least the domain) match the rDNS\n  hostname(s).\n\n* host\\_mismatch=true\n\n  If HELO is called multiple times, checks if the hostname differs between\n  EHLO invocations.\n\n* proto\\_mismatch=true\n\n  If EHLO was sent and the host later tries to then send HELO or vice-versa.\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"* valid\\_hostname=true\n\n  Checks that the HELO has at least one '.' in it and the organizational\n  name is possible (ie, a host within a Public Suffix).\n\n* bare\\_ip=true\n\n  Checks for HELO <IP> where the IP is not surrounded by square brackets.\n  This is an RFC violation so should always be enabled.\n\n* dynamic=true\n\n  Checks to see if all or part the connecting IP address appears within\n  the HELO argument to indicate that the client has a dynamic IP address.\n\n* literal\\_mismatch=1|2|3\n\n  Checks to see if the IP literal used matches the connecting IP address.\n  If set to 1, the full IP must match.  If set to 2, the /24 must match.\n  If set to 3, the /24 may match, or the IP can be private (RFC 1918).\n\n* match\\_re=true\n\n  See above. This is merely an on/off toggle.\n\n* big\\_company=true\n\n  See below. This is merely an on/off toggle.\n\n* forward\\_dns=true\n\n  Perform a DNS lookup of the HELO hostname and validate that the IP of\n  the remote is included in the IP(s) of the HELO hostname.\n\n  This test requires that the valid\\_hostname check is also enabled.\n\n* rdns\\_match=true\n\n  Sees if the HELO hostname (or at least the domain) match the rDNS\n  hostname(s).\n\n* host\\_mismatch=true\n\n  If HELO is called multiple times, checks if the hostname differs between\n  EHLO invocations.\n\n* proto\\_mismatch=true\n\n  If EHLO was sent and the host later tries to then send HELO or vice-versa.\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"reject"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"reject"}]}]},{"type":"element","tag":"code","props":{"code":"For all of the checks included above, a matching key in the reject section\ncontrols whether messages that fail the test are rejected.\n\nDefaults shown:\n\n[reject]\nhost_mismatch=false\nliteral_mismatch=false\nproto_mismatch=false\nrdns_match=false\ndynamic=false\nbare_ip=false\nvalid_hostname=false\nforward_dns=false\nbig_company=false\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"For all of the checks included above, a matching key in the reject section\ncontrols whether messages that fail the test are rejected.\n\nDefaults shown:\n\n[reject]\nhost_mismatch=false\nliteral_mismatch=false\nproto_mismatch=false\nrdns_match=false\ndynamic=false\nbare_ip=false\nvalid_hostname=false\nforward_dns=false\nbig_company=false\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"skip"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"skip"}]}]},{"type":"element","tag":"code","props":{"code":"* private\\_ip=true\n\n  Bypasses checks for clients within RFC1918, Loopback or APIPA IP address ranges.\n\n* relaying\n\n  Bypass checks for clients who have relaying privileges (whitelisted IP,\n  SMTP-AUTH, etc).\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"* private\\_ip=true\n\n  Bypasses checks for clients within RFC1918, Loopback or APIPA IP address ranges.\n\n* relaying\n\n  Bypass checks for clients who have relaying privileges (whitelisted IP,\n  SMTP-AUTH, etc).\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"bigco"},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"bigco"}]}]},{"type":"element","tag":"code","props":{"code":"  A list of <helo>=<rdns>[,<rdns>...] to match against. If the HELO matches\n  what's on the left hand side, the reverse-DNS must match one of the\n  entries on the right hand side or the mail is blocked.\n\n  Example:\n\n        yahoo.com=yahoo.com,yahoo.co.jp\n        aol.com=aol.com\n        gmail.com=google.com\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  A list of <helo>=<rdns>[,<rdns>...] to match against. If the HELO matches\n  what's on the left hand side, the reverse-DNS must match one of the\n  entries on the right hand side or the mail is blocked.\n\n  Example:\n\n        yahoo.com=yahoo.com,yahoo.co.jp\n        aol.com=aol.com\n        gmail.com=google.com\n"}]}]}]}]},"navigation":{"title":"helo.checks"},"_type":"markdown","_id":"content:8.plugins:helo.checks.md","_source":"content","_file":"8.plugins/helo.checks.md","_extension":"md"},{"_path":"/plugins/limit","_dir":"plugins","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"limit - Limits plugin for Haraka","description":"Haraka limit plugin - Limits the number of messages per connection","excerpt":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"limit-plugin"},"children":[{"type":"text","value":"limit plugin"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Apply several types of limits to SMTP connections."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Each limit type has a max value that can be defined in limit.ini. The default is empty / disabled until a value has been set."}]},{"type":"element","tag":"h2","props":{"id":"concurrency"},"children":[{"type":"text","value":"concurrency"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"[concurrency]max"}]},{"type":"text","value":" is defined, it limits the maximum number of simultaneous connections per IP address. Connection attempts in excess of the limit are delayed for "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"disconnect_delay"}]},{"type":"text","value":" seconds (default: 3) before being disconnected."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This works best in conjunction with a history / reputation database, so that\none can assign very low concurrency (1) to bad or unknown senders and higher\nlimits for reputable mail servers."}]},{"type":"element","tag":"h3","props":{"id":"history"},"children":[{"type":"text","value":"History"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"History: when enabled, the "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"history"}]},{"type":"text","value":" setting is the name of a plugin that stores IP history / reputation results. The result store must have a positive value for good connections and negative integers for poor / undesirable connections. Karma is one such plugin."}]},{"type":"element","tag":"h2","props":{"id":"recipients"},"children":[{"type":"text","value":"recipients"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"[recipients]max"}]},{"type":"text","value":" is defined, each connection is limited to that number of recipients. The limit is imposed against "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"all"}]},{"type":"text","value":" recipient attempts. Attempts in excess of the limit are issued a temporary failure."}]},{"type":"element","tag":"h2","props":{"id":"unrecognized_commands"},"children":[{"type":"text","value":"unrecognized_commands"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"[unrecognized_commands]max"}]},{"type":"text","value":" is set, a connection that exceeeds the limit is disconnected."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unrecognized commands are normally SMTP verbs invalidly issued by the client.\nExamples:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"issuing AUTH when we didn't advertise AUTH extension"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"issuing STARTTLS when we didn't advertise STARTTLS"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"invalid SMTP verbs"}]}]},{"type":"element","tag":"h3","props":{"id":"limitations"},"children":[{"type":"text","value":"Limitations"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The unrecognized_command hook is used by the "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"tls"}]},{"type":"text","value":" and "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"auth"}]},{"type":"text","value":" plugins, so\nrunning this plugin before those would result in valid operations getting\ncounted against that connections limits. The solution is simple: list\n"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"limit"}]},{"type":"text","value":" in config/plugins after those."}]},{"type":"element","tag":"h2","props":{"id":"errors"},"children":[{"type":"text","value":"errors"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"[errors]max"}]},{"type":"text","value":" is set, a connection that exceeeds the limit is disconnected. Errors that count against this limit include:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"issuing commands out of turn (MAIL before EHLO, RCPT before MAIL, etc)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"attempting MAIL on port 465/587 without AUTH"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MAIL or RCPT addresses that fail to parse"}]}]},{"type":"element","tag":"h1","props":{"id":"error-handling"},"children":[{"type":"text","value":"Error Handling"}]},{"type":"element","tag":"h2","props":{"id":"too-high-counters"},"children":[{"type":"text","value":"Too high counters"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If the NoSQL store is Redis and Haraka is restarted or crashes while active\nconnections are open, the concurrency counters might be inflated. This is\nhandled by the "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"concurrency"}]},{"type":"text","value":"reset setting (default: 10m), which:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ssc: sets collection expiration time"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"redis: empties the concurrency hash"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RAM: empties the in-memory hash of all keys"}]}]},{"type":"element","tag":"h2","props":{"id":"too-low-counters"},"children":[{"type":"text","value":"Too low counters"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Because the redis and RAM objects are emptied periodically, connections that\nare open while the collections are emptied will be too low. When\nthat happens, log messages like these might be emitted:"}]},{"type":"element","tag":"code","props":{"code":"resetting 0 to 1\nresetting -1 to 1\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"resetting 0 to 1\nresetting -1 to 1\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This is a harmless error condition that is repaired automatically."}]}]},"navigation":{"title":"limit"},"_type":"markdown","_id":"content:8.plugins:limit.md","_source":"content","_file":"8.plugins/limit.md","_extension":"md"}]